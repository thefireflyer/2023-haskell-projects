#import "@local/utils:0.1.0": *
#show: doc.with(title: [IL Semantics])
//============================================================================//

= Definitions

- System $F_omega^mu$ (hopefully)
- Largely based on Pierce's definitions.

Definition. Let *ILCore* be the language generated by the following rules.
#bnf(
  Prod($"`t"$, annot: [_terms_], {
    Or[$"`x"$][_variable_]
    Or[$lambda"`x:T.t"$][_abstraction_]
    Or[$"`t t"$][_application_]
    Or[$lambda"`X::K.t"$][_type abstraction_]
    Or[$"`t [T]"$][_type application_]
    Or[${"*`T","`t"}"` as T"$][_packing_]
    Or[$"`let "{"`X,x"}="`t in t"$][_unpacking_]
    Or[$"`fold [T] t"$][_folding_]
    Or[$"`unfold [T] t"$][_unfolding_]
  }),
  Prod($"`T"$, annot: [_types_], {
    Or[$"`X"$][_type variable_]
    Or[$"`T" -> "`T"$][_type of functions_]
    Or[$mu"`X.T"$][_recursive type_]
    Or[$forall"`X::K.t"$][_universal type_]
    Or[${exists"`X::K","`T"}$][_existential type_]
    Or[$lambda"`X::K.t"$][_operator abstraction_]
    Or[$"`T T"$][_operator application_]
    Or[$"`B"$][_base types_]
  }),
  Prod($"`K"$, annot: [_kinds_], {
    Or[$star$][_kind of proper types_]
    Or[$"`K" => "`K"$][_kind of operators_]
  }),
)

Definition. Let the following ILCore terms be called *values*.
#bnf(Prod($"`v"$, annot: [_values_], {
  Or[$lambda"`x:T.t"$][_abstraction_]
  Or[$lambda"`X::K.t"$][_type abstraction_]
  Or[${"*`T","`v"}"` as T"$][_packing_]
  Or[$"`fold [T] v"$][_folding_]
}))

Definition. Let the context $Gamma$ be a set of elements of the following forms.
#bnf(Prod($Gamma$, annot: [_contexts_], {
  Or[$"`x:T"$][_term variable binding_]
  Or[$"`X::K"$][_type variable binding_]
}))


Definition. Let the ILCore *one-step evaluation* relation ($-->$) be the smallest binary relation on terms satisfying the following inference rules.

$
  #prooftree(rule(
    $"`if" "`t"_1 "`then" "`t"_2 "`else" "`t"_3 --> "`if" "`t"_1 "`then" "`t"'_2 "`else" "`t"_3$,
    $"`t"_2 --> "`t"'_2$,
  ))
$

// Definition. Let $"`t""-->*""`t'"$ denote that $("`t","`t'")$ is an element of the transitive-reflexive closure of the one-step evaluation relation.

Definition. Let the ILCore *typing* relation be the smallest binary relation between terms and types satisfying the following inference rules.

$
  #prooftree(rule($...:...$, $...$))
$

Definition. Let the ILCore *term ordering* relation be ....

$
  #prooftree(rule($...:...$, $...$))
$


//============================================================================//

= Properties

*Summary:*
- Inversion Lemmas
- Turing Completeness
- Type Progress Theorem
- Type Preservation Theorem

== Evaluation Properties

#theorem("2.1.1", [
  For all terms $"`t","`t'"$ and $"`t''"$, if $"`t"-->"`t'"$ and $"`t"-->"`t''"$, then $"`t'"="`t''"$.
])

Proof. ...

#theorem("2.1.2", [
  // inversion lemma.
  ...
])

Proof. ...


== Typing Properties

#theorem("2.2.1", [
  // type determinacy
  ...
])

Proof. ...

#theorem("2.2.2", [
  // inversion lemma.
  ...
])

Proof. ...

//============================================================================//

= Derived Forms

//============================================================================//

= Complete Language Definition

//============================================================================//

= Examples


//============================================================================//
